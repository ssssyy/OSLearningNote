* 在使用高级语言编写用户程序的时候，手动用嵌入汇编的方法随机访问一个不在当前程序逻辑地址范围内的地址，比如向该地址读/写数据。该用户程序执行的时候可能会生什么？
** 会发生内存段错误，例如访问了受到保护的地址/页表没有映射到的空地址，SIGSEGV信号。

* 用户程序在运行的过程中，看到的地址是逻辑地址还是物理地址？从用户程序访问某一个地址，到实际内存中的对应单元被读/写，会经过什么样的过程，这个过程中操作系统有什么作用？（站在学过计算机组成原理的角度）
** 用户程序看到的都是逻辑地址，用户程序的逻辑地址经过MMU查询页表转换为物理地址，操作系统提供了页表PTE相关的访问，以及缺页的时候的系统调度处理。

* 覆盖、交换和虚拟存储有何异同，虚拟存储的优势和挑战体现在什么地方？
** 覆盖是用新的直接取代旧的，直接用牺牲算法决定即可；交换则是选择了暂时不用的旧的时，把它从内存里存到磁盘上，留出内存空间给新的要用的页面。虚拟存储的优势在于可以扩大程序能使用的存储空间，挑战包括如何设计页表结构来获得更高的命中率，以及交换算法和批量写入等提高性能的实现。

* 什么是局部性原理？为何很多程序具有局部性？局部性原理总是正确的吗？为何局部性原理为虚拟存储提供了性能的理论保证？
** 局部性原理指程序运行时总倾向于访问当前内存附近的内存，因为程序的指令绝大多数都是顺序排列和访问的，而数据在循环存在的情况下也大多会重复多次访问附近的内存。并不总是正确，数据有时候是无规律分布的。由于虚拟内存中物理内存只占一小部分，因此在局部性存在时，只需要很小一部分内存空间就可以存储程序需要的指令和数据，因此虚拟内存可以有很高的页面命中率，使程序运行速度和完全基于物理内存的访问速度相似。 

** 一条load指令，最多导致多少次页访问异常？尝试考虑较多情况。
*** 取指令时可能触发缺页异常，访问内存指定的位置时也可能出现缺页异常，每一级根页表除外的页表都可能发生缺页异常，因此3级页表情况下，每次访存都可能出现3次异常，也就是6次。

** 如果在页访问异常中断服务例程执行时，再次出现页访问异常，这时计算机系统（软件或硬件）会如何处理？这种情况可能出现吗？
*** 不允许同一级的嵌套中断，因为在处理中断时设置了中断屏蔽位，所以此时到来的同一级中断不会被处理，直到当前中断处理完返回。

* 全局和局部置换算法有何不同？分别有哪些算法？
** 全局可以选择当前所有能换出的页面，而局部置换算法仅能选择当前进程占有的页面。全局算法包括工作集算法、缺页率算法，局部置换算法包括LRU、LFU、时钟算法、FIFO等。 

* 简单描述OPT、FIFO、LRU、Clock、LFU的工作过程和特点 (不用写太多字，简明扼要即可)
** OPT：理想情况，假设能知道整个程序的访问内存流程，则可以在此基础上设计出最优的替换算法；FIFO是先进先出算法，先换入的页面先被换出；LFU是最近使用频率最少的，给定一个时间窗口，替换掉时间窗口内访问最少的；Clock是时钟算法，会按照一圈的方式轮流替换页面；LRU是最远使用，每次都替换最久没访问的。

** 综合考虑置换算法的收益和开销，综合评判在哪种程序执行环境下使用何种算法比较合适？
*** 略

** Clock算法仅仅能够记录近期是否访问过这一信息，对于访问的频度几乎没有记录，如何改进这一点？
*** 可以在clock关联的位置上同时记录每个页面的频度。

*** 哪些算法有belady现象？思考belady现象的成因，尝试给出说明OPT和LRU等为何没有belady现象。 
**** FIFO有，因为先进先出的本质与内存访问的局部性矛盾。其他算法是遵从局部性原则的，因此不会造成分配越多失效率越高的情况。

* 什么是工作集？什么是常驻集？简单描述工作集算法的工作过程。
** 工作集是一段时间内程序运行时访问的内存集合，常驻集是常驻内存中的工作集，工作集算法是利用miss率等指标来计算出合适的工作集内存大小的适应性算法。

* 请列举 SV39 页`*` 页表项的组成，结合课堂内容，描述其中的标志位有何作用／潜在作用？

** 请问一个任务处理 10G 连续的内存页面，需要操作的页表实际大致占用多少内存(给出数量级即可)？

** 缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断，告知操作系统：该进程内存访问出了问题。然后操作系统可选择填补页表并重新执行异常指令或者杀死进程。操作系统基于缺页异常进行优化的两个常见策略中，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 操作系统并不会马上这样做，而是会保存 .text 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。 另一个常见策略是 swap 页置换策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效，操作系统在任务访问到该页产生异常时，再把数据从磁盘加载到内存。

哪些异常可能是缺页导致的？发生缺页时，描述与缺页相关的CSR寄存器的值及其含义。
答：page fault

Lazy 策略有哪些好处？请描述大致如何实现Lazy策略？
答：减少了不必要的实际数据传送，如果一个页面在一次运行过程中根本没用到，则不需要实际换入，常用于很多临时性的启动程序等，它的页面不会被使用而且会很快被换掉。在pte里分配对应的指针，但是不换入实际内容，等到缺页异常发生时由操作系统换入发生数据传送。

swap 页置换策略有哪些好处？此时页面失效如何表现在页表项(PTE)上？请描述大致如何实现swap策略？
答：交换可以把不常用的放在访问时间更长的磁盘上，构造一种很大的地址空间，并且对应用程序透明。页面失效在PTE上记录其在磁盘上的地址，并记录位，访问时会引起缺页异常。修改选中的牺牲页面pte为磁盘地址，将页面内容写入磁盘，然后再将新的页面覆盖这一物理内存页面。

** 为了防范侧信道攻击，本章的操作系统使用了双页表。但是传统的操作系统设计一般采用单页表，也就是说，任务和操作系统内核共用同一张页表，只不过内核对应的地址只允许在内核态访问。(备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 KPTI )

单页表情况下，如何控制用户态无法访问内核页面？
答：通过设置PTE的S/U字段控制页面的访问权，类似于RWX字段的控制。

相对于双页表，单页表有何优势？
答：单页表减少了系统调用时的页表失效成本，在切换运行态时不用换入换出页表以及根页表指针，同时可以让内核态方便的访问到用户态的页表，而不需要额外的api接口。

请描述：在单页表和双页表模式下，分别在哪个时机，如何切换页表？
答：单页表在进程切换时切换页表；双页表在进程切换以及发生系统调用以及系统调用执行完毕退出时切换页表。切换页表会将原来的根页表指针当作context存在栈中，将新的根页表指针从栈中读取出来放入特殊的寄存器中，并设置原有的pte失效。
