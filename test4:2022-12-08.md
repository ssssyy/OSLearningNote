假设操作系统能够帮我们做虚拟地址和物理地址之间的映射，那么我们就可以在linker中指定每个应用程序的地址都是相同且固定的0x1000——这符合os课程上说明的，虚拟内存能够简化内存的排布以及链接器的实现。

每个应用程序有自己独立的页表，因此发生调度的时候也需要切换应用程序之间的根页表指针。同理，在发生系统调用的时候，之前使用的alltraps函数和restore函数也需要跟随着sp的转换，同时切换页表。

获取应用的ELF格式方式：

对每个ELF的解析方式：


另一个已知的需要改进的地方是，不同特权级的页表需要留一个“口子”，让其他特权级的程序也能够访问，例如，S-mode应该能从api处访问用户页表的内容，否则系统调用就难以实现了。

在程序中能够直接看到的变量都是被静态分配在栈或者全局数据段上的，它们大小在编译期已知，它们可能指向一个堆上的动态内存部分。

这一章的讲义主要在讲虚拟内存的分配、对齐等问题，以及mmu部件去解码的方式，属于是原有的system知识的复习。

复习段式、页式、段页式内存管理，段表+页表。


# SV39分页
设置satp字段后，可以让S和U级别都是要经过MMU转换的地址，得到一个39位的虚拟地址

## satp字段
MODE控制页表实现方式，PPN是根页表物理页号

## 参数
页面大小是4KiB，所以Offset设置为12位，剩下的是VPN

## 抽象实现
它们的大小其实就是一个usize指针的大小，但是实现为VA、PA、VPN、PPN的不同形式，保证类型安全

## PTE
PTE的各位含义见文档，DAGUXWRV

## 地址翻译以及字段组合
看以前的教材即可，原理是逐级翻译
